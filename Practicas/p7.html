<!DOCTYPE html>
<html>

<head>
    <title>WebGL projections: perspective</title>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/3.4.2/gl-matrix-min.js"></script>

    <script id="shaderVs" type="x-shader/x-vertex">
        attribute vec4 a_Position;
        attribute vec2 a_TexCoord;
        attribute vec3 a_Normal;
        varying vec2 v_TexCoord;
        varying highp vec4 v_Normal;

        uniform mat4 u_pMatrix;
        uniform mat4 u_vMatrix;
        uniform mat4 u_mvMatrix;
        uniform mat4 u_nMatrix;
        
        void main() {
            v_Normal = u_nMatrix * vec4(a_Normal, 1.0);
            gl_Position = u_pMatrix * u_vMatrix * u_mvMatrix * a_Position;
            v_TexCoord = a_TexCoord;
        }
    </script>

    <script id="shaderFs" type="x-shader/x-fragment">
        precision mediump float;
        uniform bool lights;
        uniform sampler2D u_Sampler0;
        uniform sampler2D u_Sampler1;
        varying vec2 v_TexCoord;
        varying highp vec4 v_Normal;

        uniform vec3 u_LightColor;
        uniform vec3 u_LightDirection;
        uniform vec3 u_AmbientLight;

        void main(void) {
            vec4 color0 = texture2D(u_Sampler0, v_TexCoord);
            vec4 color1 = texture2D(u_Sampler1, v_TexCoord);

            float nDotL = max(dot(u_LightDirection, normalize(v_Normal.xyz)), 0.0);

            if (lights) {
                vec3 diffuse = 0.5 * u_LightColor * color0.rgb * nDotL;
                vec3 ambient = u_AmbientLight * color0.rgb;
                gl_FragColor = vec4(diffuse + ambient, color0.a);
            } else {
                vec3 diffuse = 0.5 * u_LightColor * color0.rgb * color1.rgb * nDotL;
                vec3 ambient = u_AmbientLight * color0.rgb * color1.rgb;
                gl_FragColor = vec4(diffuse + ambient, color0.a * color1.a);
            }
        }
    </script>

    <script>
        
        var gl;
        var countX = 0.0;
        var countY = 0.0;
        var countZ = 3;

        function init() {
            // Get canvas object from the DOM
            var canvas = document.getElementById("myCanvas");
            
            document.addEventListener('wheel', function(ev) {
                    countZ = ev.wheelDelta > 0 ? countZ - 0.5 : countZ + 0.5;
                });

            // Init WebGL context
            gl = canvas.getContext("webgl");
            if (!gl) {
                console.log("Failed to get the rendering context for WebGL");
                return;
            }

            // Init shaders
            var vs = document.getElementById('shaderVs').innerHTML;
            var fs = document.getElementById('shaderFs').innerHTML;
            initShaders(gl, vs, fs);

            // Init vertex shader
            initVertexShader(gl);

            // Init projection matrix
            initProjection(gl, canvas);

            // Set clear canvas color
            gl.clearColor(0.0, 0.0, 0.0, 1.0);

            // Hidden surface removal
            gl.enable(gl.DEPTH_TEST);

            // Init textures
            initTexturesAndDraw(gl);
        }

        function drawScene() {
            // Clear
            gl.clear(gl.COLOR_BUFFER_BIT);
           
            var rotationChecked = document.querySelector('input[name="rotation"]:checked');
            var primitiveValue = document.querySelector('input[name="primitive"]:checked').value;
            var projectionValue = document.querySelector('input[name="projection"]:checked').value;
            var speed = document.getElementById("speed").value;
            var christmas = document.querySelector('input[name="christmas"]:checked').value;

            var translated = glMatrix.mat4.fromXRotation(glMatrix.mat4.create(), countX);
            var rotated = glMatrix.mat4.fromYRotation(glMatrix.mat4.create(), countY*speed);
            var matrix = glMatrix.mat4.multiply(glMatrix.mat4.create(), translated, rotated);
            var mvMatrixUniform = gl.getUniformLocation(gl.program, "u_mvMatrix");
            var l = gl.getUniformLocation(gl.program, "lights");

            // Rotate
            if (rotationChecked) {
                countY += 0.01;
            }

            // Draw
            var canvas = document.getElementById("myCanvas");
            initProjection(gl, canvas);

            if (projectionValue == "perspective") {
                z2 = countZ;
                gl.uniformMatrix4fv(mvMatrixUniform, false, matrix);
                initProjection(gl, canvas, 0)
            } else if (projectionValue == "orthographic") {
                gl.uniformMatrix4fv(mvMatrixUniform, false, rotated);
                initProjection(gl, canvas, 1)
            }

            if (primitiveValue == "lines"){
                gl.drawElements(gl.LINE_STRIP, 90, gl.UNSIGNED_SHORT, 0);
            } else if (primitiveValue == "triangles"){
                gl.drawElements(gl.TRIANGLES, 90, gl.UNSIGNED_SHORT, 0);
            }

            if (christmas == "no") {
                gl.uniform1i(l, false);
            } else if (christmas == "yes") {
                gl.uniform1i(l, true);
            }

            document.onkeydown = function (ev) {
                var step = new Number(document.getElementById("step").value);
                switch (ev.keyCode) {
                    case 38: // Up
                        countX += step;
                        break;
                    case 40: // Down
                        countX += -step;
                        break;
                }
            }

            // Call drawScene again in the next browser repaint
            requestAnimationFrame(drawScene);
    }

        function initVertexShader(gl) {
            // Vertexes and textures coordinates
            var vertexesAndTextures = [
                // piramid 1
                0.0, 0.7, 0.0,       0.25, 1.0, // v0
                -0.4, 0.25, 0.4,     0.0, 0.5, // v1
                0.4, 0.25, 0.4,      0.5, 0.5, // v2
                0.4, 0.25, -0.4,     0.0, 0.5, // v3
                -0.4, 0.25, -0.4,    0.5, 0.5, // v4

                -0.4, 0.25, 0.4,     0.0, 1.0, // v5
                0.4, 0.25, 0.4,      0.5, 1.0, // v6
                0.4, 0.25, -0.4,     0.0, 0.5, // v7
                -0.4, 0.25, -0.4,    0.5, 0.5, // v8
                // piramid 2
                0.0, 0.5, 0.0,       0.75, 1.0, // v9
                -0.5, 0.0, 0.5,      0.5, 0.5, // v10
                0.5, 0.0, 0.5,       1.0, 0.5, // v11
                0.5, 0.0, -0.5,      0.5, 0.5, // v12
                -0.5, 0.0, -0.5,     1.0, 0.5, // v13

                -0.5, 0.0, 0.5,      0.5, 1.0, // v14
                0.5, 0.0, 0.5,       1.0, 1.0, // v15
                0.5, 0.0, -0.5,      0.5, 0.5, // v16
                -0.5, 0.0, -0.5,     1.0, 0.5, // v17
                // piramid 3
                0.0, 0.3, 0.0,       0.25, 1.0, // v18
                -0.6, -0.25, 0.6,    0.0, 0.5, // v19
                0.6, -0.25, 0.6,     0.5, 0.5, // v20
                0.6, -0.25, -0.6,    0.0, 0.5, // v21
                -0.6, -0.25, -0.6,   0.5, 0.5, // v22

                -0.6, -0.25, 0.6,    0.0, 1.0, // v23
                0.6, -0.25, 0.6,     0.5, 1.0, // v24
                0.6, -0.25, -0.6,    0.0, 0.5, // v25
                -0.6, -0.25, -0.6,   0.5, 0.5, // v26
                // trunk
                -0.2, -0.25, 0.2,    0.5, 0.5, // v27
                -0.2, -0.25, -0.2,   1.0, 0.5, // v28
                -0.2, -0.60, 0.2,    0.5, 0.0, // v29
                -0.2, -0.60, -0.2,   1.0, 0.0, // v30
                0.2, -0.25, 0.2,     0.5, 0.5, // v31
                0.2, -0.25, -0.2,    1.0, 0.5, // v32
                0.2, -0.60, 0.2,     0.5, 0.0, // v33
                0.2, -0.60, -0.2,    1.0, 0.0, // v34

                -0.2, -0.25, 0.2,    0.0, 0.5, // v35
                0.2, -0.25, 0.2,     0.5, 0.5, // v36
                -0.2, -0.60, 0.2,    0.0, 0.0, // v37
                0.2, -0.60, 0.2,     0.5, 0.0, // v38
                -0.2, -0.25, -0.2,   0.5, 0.5, // v39
                0.2, -0.25, -0.2,    1.0, 0.5, // v40
                -0.2, -0.60, -0.2,   0.5, 0.0, // v41
                0.2, -0.60, -0.2,    1.0, 0.0, // v42

                -0.2, -0.60, 0.2,    0.5, 0.5, // v43
                -0.2, -0.60, -0.2,   1.0, 0.5, // v44
                0.2, -0.60, 0.2,     0.5, 0.0, // v45
                0.2, -0.60, -0.2,    1.0, 0.0, // v46
            ];

            // Indexes (for drawing squares using triangles)
            var indexes = [
                // piramid 1
                0, 1, 2,
                0, 2, 3,
                0, 3, 4,
                0, 4, 1,
                5, 6, 7,
                5, 7, 8,
                // piramid 2
                9, 10, 11,
                9, 11, 12,
                9, 12, 13,
                9, 13, 10,
                14, 15, 16,
                14, 16, 17,
                // piramid 3
                18, 19, 20,
                18, 20, 21,
                18, 21, 22,
                18, 22, 19,
                23, 24, 25,
                23, 25, 26,
                // trunk
                27, 28, 29,
                29, 28, 30,
                35, 36, 37,
                36, 37, 38,
                31, 32, 33,
                33, 34, 32,
                39, 40, 41,
                40, 41, 42,
                27, 31, 32,
                27, 28, 32,
                43, 44, 46,
                43, 46, 45,
            ];

            var normals = new Float32Array([
                // piramid 1    
                0, 0, 1, 0, 0, 1, 0, 0, 1,    // front
                1, 0, 0, 1, 0, 0, 1, 0, 0,    // right
                0, 0, -1, 0, 0, -1, 0, 0, -1, // back
                -1, 0, 0, -1, 0, 0, -1, 0, 0, // left
                0, -1, 0, 0, -1, 0, 0, -1, 0, // down
                // piramid 2    
                0, 0, 1, 0, 0, 1, 0, 0, 1,    // front
                1, 0, 0, 1, 0, 0, 1, 0, 0,    // right
                0, 0, -1, 0, 0, -1, 0, 0, -1, // back
                -1, 0, 0, -1, 0, 0, -1, 0, 0, // left
                0, -1, 0, 0, -1, 0, 0, -1, 0, // down
                // piramid 3    
                0, 0, 1, 0, 0, 1, 0, 0, 1,    // front
                1, 0, 0, 1, 0, 0, 1, 0, 0,    // right
                0, 0, -1, 0, 0, -1, 0, 0, -1, // back
                -1, 0, 0, -1, 0, 0, -1, 0, 0, // left
                0, -1, 0, 0, -1, 0, 0, -1, 0, // down
                // trunk   
                0, 0, 1, 0, 0, 1, 0, 0, 1,    // front
                1, 0, 0, 1, 0, 0, 1, 0, 0,    // right
                0, 0, -1, 0, 0, -1, 0, 0, -1, // back
                -1, 0, 0, -1, 0, 0, -1, 0, 0, // left
                0, 0, 0, 0, 0, 0, 0, 0, 0,    // up
                0, -1, 0, 0, -1, 0, 0, -1, 0, // down
            ])

            // Write a_Position and a_Color using gl.ARRAY_BUFFER
            gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexesAndTextures), gl.STATIC_DRAW);

            var vertexPositionAttribute = gl.getAttribLocation(gl.program, "a_Position");
            gl.enableVertexAttribArray(vertexPositionAttribute);
            gl.vertexAttribPointer(vertexPositionAttribute, 3, gl.FLOAT, false, 4 * (3 + 2), 0);

            var vertexColorAttribute = gl.getAttribLocation(gl.program, "a_TexCoord");
            gl.enableVertexAttribArray(vertexColorAttribute);
            gl.vertexAttribPointer(vertexColorAttribute, 2, gl.FLOAT, false, 4 * (3 + 2), 4 * 3);

            gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
	        gl.bufferData(gl.ARRAY_BUFFER, normals, gl.STATIC_DRAW);

            var vertexNormalAttribute = gl.getAttribLocation(gl.program, "a_Normal");
            gl.enableVertexAttribArray(vertexNormalAttribute);
            gl.vertexAttribPointer(vertexNormalAttribute, 3, gl.FLOAT, false, 0, 0);

            // Write indexes in gl.ELEMENT_ARRAY_BUFFER
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gl.createBuffer());
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indexes), gl.STATIC_DRAW);
        }
		
		function toRadian(g){
			return g*Math.PI/180;
		}

        function initProjection(gl, canvas, n) {
            var pMatrixUniform = gl.getUniformLocation(gl.program, "u_pMatrix");
            var vMatrixUniform = gl.getUniformLocation(gl.program, "u_vMatrix");
            var ratio = canvas.width / canvas.height;
            
            if (n == 0){
                var pMatrix = glMatrix.mat4.perspective(glMatrix.mat4.create(), toRadian(60), ratio, 0.1, 100);
                var vMatrix = glMatrix.mat4.lookAt(glMatrix.mat4.create(), [0, 0, z2], [0, 0, 0], [0, 1, 0]);
                gl.uniformMatrix4fv(pMatrixUniform, false, pMatrix);
                gl.uniformMatrix4fv(vMatrixUniform, false, vMatrix);
            }
            else if (n == 1){
                var pMatrix = glMatrix.mat4.ortho(glMatrix.mat4.create(), -ratio, ratio, -1.0, 1.0, -1.0, 1.0);
                var vMatrix = glMatrix.mat4.lookAt(glMatrix.mat4.create(), [1, 1, 1], [1, 1, 1], [1, 1, 1]);
                gl.uniformMatrix4fv(pMatrixUniform, false, pMatrix);
                gl.uniformMatrix4fv(vMatrixUniform, false, vMatrix);
            }

            // Write u_AmbientLight
            var r = document.getElementById("r").value;
            var g = document.getElementById("g").value;
            var b = document.getElementById("b").value;
            var ambientLight = [ r, g, b ];
            var ambientLightUniform = gl.getUniformLocation(gl.program, "u_AmbientLight");
            gl.uniform3fv(ambientLightUniform, ambientLight);
            
            // Write u_LightColor
            var lightColor = [ 1.0, 1.0, 1.0 ]; // white
            var lightColorUniform = gl.getUniformLocation(gl.program, "u_LightColor");
            gl.uniform3fv(lightColorUniform, lightColor);

            // Write u_LightDirection
            var x = document.getElementById("x").value;
            var y = document.getElementById("y").value;
            var z = document.getElementById("z").value;
            var lightDirection = [ x, y, z ];
            glMatrix.vec3.normalize(lightDirection, lightDirection);
            var lightDirectionUniform = gl.getUniformLocation(gl.program, "u_LightDirection");
            gl.uniform3fv(lightDirectionUniform, lightDirection);
        }

        function initTexturesAndDraw(gl) {
            var image0 = new Image();
            image0.src = 'tree.jpg';
            var image1 = new Image();
            image1.src = 'light.jpg';

            image0.onload = function () {
                loadTexture(gl, "u_Sampler0", image0, 0, true);
                image1.onload = function () {
                    loadTexture(gl, "u_Sampler1", image1, 1, true);
                    drawScene(gl);
                };
            };
        }

        function loadTexture(gl, samplerUniform, image, unitNumber, flip) {
            // Flip the image's y axis
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flip);

            // Activate and configure texture
            gl.activeTexture(gl.TEXTURE0 + unitNumber);
            gl.bindTexture(gl.TEXTURE_2D, gl.createTexture());
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);

            // Set texture to the sampler
            var fragmentSamplerUniform = gl.getUniformLocation(gl.program, samplerUniform);
            gl.uniform1i(fragmentSamplerUniform, unitNumber);
        }

        function initShaders(gl, vs_source, fs_source) {
            // Compile shaders
            var vertexShader = makeShader(gl, vs_source, gl.VERTEX_SHADER);
            var fragmentShader = makeShader(gl, fs_source, gl.FRAGMENT_SHADER);

            // Create program
            var glProgram = gl.createProgram();

            // Attach and link shaders to the program
            gl.attachShader(glProgram, vertexShader);
            gl.attachShader(glProgram, fragmentShader);
            gl.linkProgram(glProgram);

            // Use program
            gl.useProgram(glProgram);
            gl.program = glProgram;
        }

        function makeShader(gl, src, type) {
            var shader = gl.createShader(type);
            gl.shaderSource(shader, src);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                alert("Error compiling shader: " + gl.getShaderInfoLog(shader));
                return;
            }
            return shader;
        }
    </script>

</head>

<body onload="init()">
    <canvas id="myCanvas" width="640" height="480"></canvas>
    <br>
    Step: <input type="text" value="0.01" id="step">
    <div>
        <b>Rotation</b>
        <input type="checkbox" name="rotation" checked>
        <input type="range" id="speed" min="1" max="3" value="1" step="1"> Speed <br>
        <b>WebGL primitive</b>
        <input type="radio" name="primitive" value="triangles" checked> Triangles
        <input type="radio" name="primitive" value="lines"> Lines <br>
        <b>Projection type</b>
        <input type="radio" name="projection" value="perspective" checked> Perspective
        <input type="radio" name="projection" value="orthographic"> Orthographic <br>
        <b>Christmas</b>
        <input type="radio" name="christmas" value="no" checked> No
        <input type="radio" name="christmas" value="yes"> Yes <br>
    </div>
    <div>
        <b>Light direction</b><br>
        <input type="range" id="x" min="-2" max="2" value="1.1" step="0.1">X<br>
        <input type="range" id="y" min="-2" max="2" value="0.8" step="0.1">Y<br>
        <input type="range" id="z" min="-2" max="2" value="1.1" step="0.1">Z<br>
    </div>
</body>

</html>